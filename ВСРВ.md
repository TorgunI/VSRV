методичка по FreeRTOS:
часть 1: http://microsin.net/programming/arm/freertos-part1.html
часть 2: http://microsin.net/programming/arm/freertos-part2.html
часть 3: http://microsin.net/programming/arm/freertos-part3.html
часть 4: http://microsin.net/programming/arm/freertos-part4.html
часть 5: http://microsin.net/programming/arm/freertos-part5.html
часть 6: http://microsin.net/programming/arm/freertos-part6.html


# 1. Дайте определение понятию реального времени и приведите примеры

Реальное время определяется соотношением срока исполнения и временем отклика и не зависит от единиц измерения времени. К примеру, система по обработке информации, требующая реализовать поступающие извне сигналы.

Или

Реальное время - это система или режим работы, в котором вычисления проводятся в течение времени, определяемого внешним процессом, с целью управления или мониторинга по результатам этих вычислений. 
![[Pasted image 20220124132835.png]]


# 2. Понятие и определение системы реального времени

Система реального времени - это аппаратно-программный комплекс, который обеспечивает получение реакции в предсказуемый интервал времени на непредсказуемый поток внешних событий.

Система реального времени зависит не только от логической корректности вычислений, но и от времени, проводящийся вычислений.

==-----==
Общая система реального времени и общего назначения различаются в разном алгоритме диспетчеризации. В общих системах реального времени приоритет динамически меняется.
![[Pasted image 20220124173216.png]]
![[Pasted image 20220124173255.png]] ^7366c7

# 3. Классификация систем реального времени. Примеры

Системы реального времени бывают трех типов:
1. ==Системы жесткого Реального Времени== гарантируют выполнение каких-либо действий за определенный интервал времени. Время отклика никогда не превышает срок исполнения, в ином случае - фатальный отказ системы. ^4da7fe
	* Например: система управления двигателем, система торможения автомобиля. ^1e2af0
	*  ![[Pasted image 20220124181919.png]]
2. ==Системы мягкого Реального Времени== успевают выполнить заданные действия за заданное время. Допускается отклонение времени отклика при условии, что среднее время отклика равно сроку исполнения. И сохраняется работоспособность системы, если срок исполнения пропущен. ^c25a40
	* Например, сервер базы данных.
	* ![[Pasted image 20220124182116.png]]
3. ==Система комбинированного Реального Времени== комбинируют два срока выполнения - короткого "с допуском" и более "жесткого". То есть, время отклика в среднем равно сроку исполнения, но меньше либо равно жесткому сроку исполнения ^137bba
	* ![[Pasted image 20220124182507.png]]
	* Например, высоко-скоростные сети передачи данных

 # 4. Свойства и параметры системы реального времени

 Для системы реального времени характерно: 
 1. Исключительная надежность и эффективность системы.
 3. Сложность и комплексность системы, вследствие стоимость ее разработки и эксплуатации высока 
 4. Реагирование на многочисленные события с гарантированным временем ответа
 5. Обеспечение интерфейсом с широким спектром нестандартных устройств ввода/вывода и стандартной периферией

Системы реального времени различаются на среду разработку и среду исполнения.

# 5. Понятие дедлайна (Deadline) или критического срока обслуживания для СРВ. Приведите примеры

Deadline - крайний срок выполнения какой-либо работы или задачи
Например, выстрел подушки безопасности в заданный срок или [[#^1e2af0]]

# 6. Понятие латентности для СРВ. Приведите примеры

Латентность или latency - задержка реакции системы. Если deadline устанавливает крайний срок выполнений работы/задачи, латентность представляет собой задержку реакции системы на прерывание, которую стараются минимизировать. Значение латентности всегда меньше значения времени обработки сигнала, так как иначе нарушается дедлайн.
Звездочка - латентность
![[Pasted image 20220124182507 1.png]]

-----
![[Pasted image 20220124184924.png]]

# 7. Дайте определение Системы реального времени. Приведите примеры

[[#2 Понятие и определение системы реального времени]]

Примеры систем, работающих в режиме реального времени:
●	АСУ ТП химического реактора;
●	бортовая система управления космического аппарата;
●	АСНИ в области ядерной физики;
●	система обработки аудио- и видеопотоков при трансляции в прямом эфире;
●	интерактивная компьютерная игра

# 8. Классификация СРВ по типам задач

Классификация систем реального времени происходит по
* режимам реального времени, которые включают в себя
	* систему жесткого реального времени
	* систему мягкого реального времени
* способу применения операционной системы реального времени
	* специализированная система реального времени
	* универсальная система реального времени

Зачастую программные комплексы работают как составная часть более крупных автоматических систем без участия человека - такие системы реального времени называются встраиваемыми.

Также существуют операционные системы реального времени (RTOS) и операционные системы общего назначения (GPOS). Например, FreeRTOS.

# 9. Состав и организационная структура типичной системы реального времени  

Система реального времени - это аппаратно-программный комплекс, состоящий из аппаратуры, общей и прикладной системы реального времени. [[#^7366c7]] 

Если СРВ строится как программный комплекс, то в общем виде она может быть представлена как комбинация трех компонент:
* прикладное программное обеспечение
* операционная система реального времени (ОСРВ)
* аппаратное обеспечение

При разработке СРВ необходим анализ соответствия характеристик этих трех компонент требованиям внешнего объекта, для управления или мониторинга предназначающееся конкретной СРВ.

----

Система реального времени, как аппаратно-программный комплекс, включает в себя датчики, регистрирующие события на объекте, модули ввода-вывода, преобразующие показания датчиков в цифровой вид, пригодный для обработки этих показаний на компьютере, и, наконец, компьютер с программой, реагирующей на события, происходящие на объекте.

![](file:///C:/Users/Admin/AppData/Local/Packages/oice_16_974fa576_32c1d314_2873/AC/Temp/msohtmlclip1/01/clip_image002.gif)


# 10.	Организационная схема СРВ
![[Pasted image 20220124200021.png]]

Контролируемая (управляемая) подсистема – диктует требования в реальном времени.

Подсистема контроля – управляет связью с оборудованием. 

Управляющая подсистема - контролирует всю деятельность инженерной системы.

Управляющая подсистема может быть представлена прикладными задачами, которые используют оборудование, управляемое подсистемой контроля.

# 11. Система мягкого реального времени
[[#^c25a40]]
Отступление от заданных временных параметров не приводит к нарушению работы системы.
Задержка реакции не критична, хотя и может привести к увеличению стоимости результатов и снижению производительности системы в целом.

Признаки:
– за опоздание результатов приходится платить;
– приемлемо снижение производительности системы, вызванное запаздыванием реакций.

Примеры:
• Интерактивные системы, (время реакции на действия пользователя должно
быть если не нормированным, то хотя бы предсказуемым и стабильным).
• Работа с пакетами в сети,
• Автомат розничной торговли,
* Обработка данных с метеостанций.

# 12.	Система комбинированного реального времени (firm real time). Приведите примеры

[[#^137bba]]

RTS в большинстве случаев решают комбинацию задач жесткого и мягкого реального времени, а также задач, не имеющих критического срока обслуживания.
Задача может переходить из статуса мягкого реального времени при пропуске некоторого срока обслуживания в статус задачи жесткого реального времени назначением критического срока обслуживания.

Примеры: 
-	мультимедиа-приложения

# 13.	Система жесткого реального времени. Приведите примеры

[[#^4da7fe]]

Если невыполнение задачи в критический срок обслуживания означает, что она вообще не была выполнена, то такие задачи называют задачами жесткого реального времени. 
В большинстве случаев о задачах жесткого реального времени говорят тогда, когда нарушение сроков критического обслуживания может нанести значительный материальный или физический ущерб. 

Примеры:
●	 система управления двигателем
●	 система торможения автомобиля
●	 подушка безопасности
●	 контроль уровня радиации

# 14.	Понятие встраиваемой системы (Embedded systems). Приведите примеры 

Встраиваемые системы (Embedded systems) можно определить как программное и аппаратное обеспечение, составляющее компоненты другой, большей системы и работающее без вмешательства человека

ИЛИ

Встроенная система (англ. embedded system) — это специализированная компьютерная система, в которой компьютер входит в состав устройства

Например: 
* Автомобиль
* Подводная лодка

# 15.	Механизмы реального времени

К механизмам СРВ относятся: 
1) Системы приоритетов и алгоритмы диспетчеризации. 
2) Механизмы межзадачного взаимодействия и синхронизации 
3) Средства для работы с таймерами. 

----
Поскольку в СРВ заложен параллелизм, поэтому ОСРВ являются многозадачными и многопоточными.
Есть системы, которые обеспечивают загрузку из СРВ. Позволяет загрузить из ПЗУ самых важных параметров.

Среди коммерческих систем реального времени можно выделить группу ведущих систем - по объемам продаж и по популярности. 
Эти системы: VxWorks, OS9, pSOS, LynxOS, QNX.

# 16.	Инструментальная система или среда разработки для СРВ 

Инструментальная система или среда разработки – это ЭВМ со средствами, которые позволяют формировать образ целевой системы. Такие средства обычно включаются в коммерческие дистрибутивы.

# 17. Понятие среды исполнения или целевая системы

Среда исполнения или по-другому целевая система предназначена исключительно для эксплуатации. Такая среда представляет собой инструментальную систему, из которой удалено все лишнее для данной прикладной задачи.

# 18. Понятие микроконтроллера (Взято из интернета)

Микроконтроллер - это микросхема для управления электронными устройствами, сочетающая в себе процессор, встроенную память и периферию. 

Отличается от микропроцессора интегрированными в микросхему устройствами ввода-вывода, таймерами и другими периферийными устройствами. По сути, это однокристальный компьютер, способный выполнять относительно простые задачи.

-----
Микроконтроллер (МК) — это специальная микросхема, предназначенная для управления электронными устройствами и осуществления взаимодействия между ними в соответствии с заложенной программой. 

В отличие от микропроцессоров, используемых в персональных компьютерах, микроконтроллеры содержат встроенные дополнительные устройства (периферию).


# 19.	Аппаратурная среда СРВ

Систему реального времени можно разделить как бы на три слоя:
1. **Ядро** - содержит только строгий минимум, необходимый для работы системы: управление задачами, их синхронизация и взаимодействие, управление памятью и устройствами ввода/вывода; размер ядра очень ограничен: часто несколько килобайт.
2. **Система управления** - содержит ядро и ряд дополнительных сервисов, расширяющих его возможности: расширенное управление памятью, вводом/выводом, задачами, файлами и т.д., обеспечивает также взаимодействие системы и управляющего/управляемого оборудования.
3. **Система реального времени** - содержит систему управления и набор утилит: средства разработки (компиляторы, отладчики и т.д.), средства визуализации (взаимодействия человека и операционной системы).

Аппаратные средства СРВ условно можно разделить на две большие группы:
• средства вычислительной техники (ЭВМ с ее стандартными устройствами и интерфейсами);
• специализированные устройства для связи ЭВМ с объектом.

# 20. Устройство связи с объектом
Устройство связи с объектом - это комплекс устройств,
обеспечивающих взаимодействие объектов внешнего мира и ЭВМ. 

# 21.	Примеры УСО (устройство связи с объектом в СРВ)

==1) Датчики== (или первичные измерительные преобразователи) - это устройства, выполняющие преобразование значения физической величины
(температуры, давления, перемещения и т.п.) в электрический сигнал. При этом информация может быть заключена в величине напряжения, тока или частоты изменения сигнала.
==2)	Промежуточные измерительные преобразователи== сохраняющие вид представления сигнала (например, напряжение остается напряжением) и его форму, но изменяющие его величину. Они необходимы в тех случаях, когда электрический сигнал, поступающий с датчика, слишком слаб по величине, либо слишком силен, либо засорен помехами и т.п. К устройствам этого типа относятся разнообразные усилители, нормализаторы, фильтры и пр.
==3) Аналогово-цифровые преобразователи== (АЦП) – устройства, предназначенные для преобразования значения электрического сигнала в число.
4) ==Цифро-аналоговые преобразователи (ЦАП)== – устройства, предназначенные для преобразования числовой величины в электрический сигнал (напряжение или ток). Свойства и технические характеристики ЦАП аналогичны АЦП.
5)	==Коммутаторы аналоговых сигналов== – устройства, осуществляющие физическое переключение (коммутацию) связей между различными
устройствами. Различают мультиплексоры (устройства, способные подключать несколько входов на один выход), демультиплексоры (устройства, способные подключать один вход к нескольким выходам) и комбинированные
коммутаторы. Существуют также коммутаторы цифровых сигналов – «свитчи».
6) ==Исполнительные устройства== – устройства, предназначенные для организации непосредственного воздействия на объект. Примером ИУ могут служить шаговый двигатель, электрический нагреватель и т.п.

# 22.	Основные виды задержек в ОСРВ

1) Задержка прерывания - это время, которое проходит от момента генерации прерывания до момента, когда источник прерывания обслуживается. Для многих операционных систем устройства обслуживаются сразу после выполнения обработчика прерывания устройства.
2) Задержка задачи - количество времени, которое должно пройти от планируемой даты начала задачи до того момента, когда должно начаться фактическое ее выполнение.
3) Задержка драйвера составляет задержку, когда драйвер отслеживает задачи.

----
          
Существует несколько видов задержек:
1. Задержка прерывания (interrupt latency) — время, которое проходит с момента генерации прерывания до запуска соответствующей подпрограммы обработки прерывания.
2. Задержка планировщика (scheduling latency) — промежуток времени между «пробуждением» (воздействием), возвещающим о том, что событие произошло, и моментом, когда у планировщика появляется возможность запланировать выполнение соответствующего потока, который ожидает это событие. Воздействие может быть вызвано аппаратным прерыванием или другими потоками. Задержку планировщика часто называют задержкой реакции (task-response latency) или задержкой диспетчеризации (dispatch latency). Нередко при планировании происходит перераспределение приоритетов и может возникнуть инверсия приоритетов — ситуация, когда какая-либо задача вытесняется другими, изначально имеющими более низкий приоритет.
3. Задержка для худшего случая (worst-case latency) — это наибольшее время, которое может пройти до наступления ожидаемого события. Этот термин имеет отношение к случаю, когда система загружена. В системах реального времени необходимо предусмотреть не только средние параметры, но и наихудшие сценарии. Вспоминая аналогию с системой безопасности автомобиля, 0,5 с — это как раз наихудший случай. При нормальных условиях подушка срабатывает за 0,2 с. Однако в случае перегрузки системы выброс подушки должен быть произведен по крайней мере через 0,5 с.

# 23.	Свойство СРВ - время реакции системы

Время реакции системы - это способность выдерживать заранее заданные интервалы времени между запуском программы и получением результата (управляющего воздействия), а соответствующее свойство системы – реактивностью. 
Время реакции системы должно быть вычислено при создании системы. Отсутствие реакции в предсказанное время считается ошибкой для систем реального времени. 
Время реакции ОС включает в себя время реакции на события, время переключения контекста и время перегрузки системы.

-----
Время реакции системы так называемая реактивность относятся к важным свойствам СРВ. Реактивность зависит от времени отклика системы. Чем меньше время отклика, тем выше реактивность системы. Чем меньше время отклика, тем больше вероятность, что система не пропустит крайний срок

# 24. Свойство ОСРВ - переключение контекста
Переключение контекста - это процесс прекращения выполнения процессором одной задачи (например, процесса, потока, нити) с сохранением всей необходимой информации и состоянием, необходимых для продолжения с прерванного места, с последующим восстановлением и загрузкой состояния задачи, к выполнению которой переходит процессор.

В процедуру переключения контекста входит планирование задачи — процесс принятия решения, какой задаче передать управление.

-----
В ОСРВ изначально заложен параллелизм, т.е. возможность одновременной обработки нескольких событий. Поэтому все ОСРВ являются многозадачными (многопроцессными или многонитевыми). Для того чтобы уметь оценить накладные расходы ОСРВ при разработке параллельных событий крайне важно знать время, которое затрачивается на передачу управления от задачи к задаче (от процесса к процессу, от нити к нити).

При смене задач в ЦП сохраняется контекст (содержимое ЦП) текущей задачи находится в области сохранения задачи. Напомним, что у любой задачи есть область кода, область данных и стек. Затем контекст задачи, которая будет запущена следует восстановить из ее области сохранения, загрузить содержимое в регистры ЦП, затем продолжается выполнение кода той задачи, чей контекст в данный момент загружен. Почему для нас так важен контекст. В идеальной системе время контекста можно не учитывать. Но если мы говорим о реальной системе и учитываем, что для нас очень важным параметром является время. То нам придётся считаться с временными затратами на переключение контекста.

На переключение контекста тратится тем больше времени ЦП, чем больше регистров у ЦП. И чем чаще происходит смена задачи.

Одна из основных функций ядра – переключение контекста. То есть диспетчер должен выбрать задачу в соответствии с дисциплиной обслуживания из очереди задач, подготовленной планировщиком.

# 25.	Свойство ОСРВ - размер системы

Размер системы исполнения - является свойством операционной системы реального времени и представляет собой суммарный объем минимально необходимого для работы приложения системного набора (ядро, драйвера, системные модули).

Размер системы исполнения остается важным и производители ОСРВ стремятся к тому, чтобы размеры ядра и обслуживающих модулей были невелики.

-----

Для ОСРВ очень важным параметром является размер системы исполнения, а именно суммарный размер минимально необходимого для работы прикладных программ приложения системного набора (системное ядро, системные модули, драйверы). С течением времени значение этого параметра снижается. Тем не менее, он остается важным, и производители ОСРВ стремятся к тому, чтобы этот параметр был не велик (например, ОСРВ OS9 – 22 Кбайт, VxWorks – 16 Кбайт).

# 26.	Свойство ОСРВ - возможность запуска из ПЗУ

Возможность исполнения системы из ПЗУ - это одно из базовых свойств ОСРВ. Оно позволяет создавать компактные встроенные СРВ повышенной надежности, с ограниченным энергопотреблением, без внешних накопителей.

# 27.	СРВ и подходы существующие к разработке СРВ

Встраиваемые системы (Embedded systems) можно определить как программное и аппаратное обеспечение, составляющее компоненты другой, большей системы и работающее без вмешательства человека. 

Два подхода – c использованием суперцикла или же с использованием RTOS (Real-Time Operation System, операционная система реального времени).

----
Встроенная система (англ. embedded system) — это специализированная компьютерная система, в которой компьютер входит в состав устройства

# 28.	Подход Суперцикл. Применение данного подхода в разработке СРВ 

Подход суперцикл - это бесконечный цикл, в котором контроллер последовательно делает все, что он должен делать
![[Pasted image 20220125190146.png]]


# 29.	Подход ОСРВ. Применение данного подхода в разработке СРВ 

Применение операционной системы реального времени на примере одновременного опроса датчика с заданной частотой и вывод на консоль длинной отладочной строки

```C++
void SensorPollingTask()

{

 while (1)

 {

 value = SensorRead();

 if (value > LIMIT)

 {

 doSomething();

 }

 taskDelay(10_MILLISECOND_DELAY);

 }

}

void DebugTask()

{

 dbg_task_queue = os_queue_create();

 while (1)

 {

 char * str = os_queue_read(dbg_task_queue);

 foreach (ch in str)

 {

 put_ch(ch);

 }

 }

}

void OtherTask()

{

 other_task_init();

 …

 while(1)

 {

 …

 _// we want to do a dbg_printout here_

 os_queue_put("Long Debug Output String");

 …

 }

}

int main()

{

 os_task_create(SensorPollingTask, HIGH_PRIORITY);

 os_task_create(DebugTask, LOW_PRIORITY);

 os_task_create(OtherTask, OTHER_PRIORITY);

 os_start_sheduler();

}
```


# 30. Ядро ОС. Классификация ОС по типу ядра. Применение для СРВ

Ядро ОСРВ обеспечивает функционирование промежуточного абстрактного уровня ОС, который скрывает от прикладного ПО специфику технического устройства процессора (нескольких процессоров) и связанного с ним аппаратного обеспечения

Классификация ОС по типу ядра: 
●	системы с монолитным ядром, которые поддерживают реализацию всех компонентов (механизмов) РВ
●	ОС с микроядерной архитектурой. QNX и OS9 – системы крупных производителей.
●	с экзоядром

Применение для СРВ:
●	Управление задачами.
●	Динамическое распределение памяти.
●	Управление таймерами.
●	Взаимодействие между задачами и синхронизация.
●	Контроль устройства ввода-вывода

# 31.	Базовый инструмент разработки сценария работы системы на основе ОСРВ 
Базовыми инструментами разработки сценария работы системы являются система приоритетов процессов (задач) и алгоритмы планирования (диспетчеризации) операционных системах реального времени.

-----
В многозадачных ОС общего назначения используются, как правило, различные модификации алгоритма круговой диспетчеризации, основанные на понятии непрерывного кванта времени ("time slice"), предоставляемого процессу для работы. Планировщик по истечении каждого кванта времени просматривает очередь активных процессов и принимает решение, кому передать управление, основываясь на приоритетах процессов (численных значениях, им присвоенных).

Приоритеты могут быть фиксированными или меняться со временем - это зависит от алгоритмов планирования в данной ОС, но рано или поздно процессорное время получат все процессы в системе. Алгоритмы круговой диспетчеризации неприменимы в чистом виде в операционных системах реального времени. Основной недостаток - непрерывный квант времени, в течение которого процессором владеет только один процесс.

Планировщики же операционных систем реального времени имеют возможность сменить процесс до истечения "time slice", если в этом возникла необходимость. Один из возможных алгоритмов планирования при этом "приоритетный с вытеснением". Мир операционных систем реального времени отличается богатством различных алгоритмов планирования: динамические, приоритетные, монотонные, адаптивные и пр., цель же всегда преследуется одна - предоставить инструмент, позволяющий в нужный момент времени исполнять именно тот процесс, который необходим.

# ==32. Планировщик ОСРВ
Планировщик (Scheduler) — это часть ядра ОСРВ, которая определяет, какая из задач, готовых к выполнению, выполняется в данный конкретный момент времени.

Когда планировщик задач получает сигнал о наступлении некоторого внешнего события, причина которого может быть как аппаратная, так и программная, он действует по следующему алгоритму:
1.	Определяет, должна ли текущая выполняемая задача продолжать работать.
2.	Устанавливает, какая задача должна запускаться следующей.
3.	Сохраняет контекст остановленной задачи (чтобы она потом возобновила работу с места остановки).
4.	Устанавливает контекст для следующей задачи.
5.	Запускает эту задачу.
Эти пять шагов алгоритма также называются переключением задач

----- 
Большинство ОСРВ выполняет планирование задач, руководствуясь следующей схемой[7]. Каждой задаче в приложении ставится в соответствие некоторый приоритет. Чем больше приоритет, тем выше должна быть реактивность задачи. Высокая реактивность достигается путём реализации подхода приоритетного вытесняющего планирования (preemptive priority scheduling), суть которого заключается в том, что планировщику разрешается останавливать выполнение любой задачи в произвольный момент времени, если установлено, что другая задача должна быть запущена незамедлительно.

Описанная схема работает по следующему правилу: если две задачи одновременно готовы к запуску, но первая обладает высоким приоритетом, а вторая — низким, то планировщик отдаст предпочтение первой. Вторая задача будет запущена только после того, как завершит свою работу первая.

Возможна ситуация, когда задача с низким приоритетом уже запущена, а планировщик получает сообщение, что другая задача с более высоким приоритетом готова к запуску. Причиной этому может послужить какое-либо внешнее воздействие (прерывание от оборудования), как, например, изменение состояния переключателя устройства, управляемого ОСРВ. В такой ситуации планировщик задач поведет себя согласно подходу приоритетного вытесняющего планирования следующим образом. Задаче с низким приоритетом будет позволено выполнить до конца текущую машинную команду (но не команду, описанную в исходнике программы языком высокого уровня), после чего выполнение задачи приостанавливается[7]. Далее запускается задача с высоким приоритетом. После того, как она прорабатывает, планировщик запускает прерванную первую задачу с машинной команды, следующей за последней выполненной.

Каждый раз, когда планировщик задач получает сигнал о наступлении некоторого внешнего события (триггер), причина которого может быть как аппаратная, так и программная, он действует по следующему алгоритму[7]:
1.	Определяет, должна ли текущая выполняемая задача продолжать работать.
2.	Устанавливает, какая задача должна запускаться следующей.
3.	Сохраняет контекст остановленной задачи (чтобы она потом возобновила работу с места остановки).
4.	Устанавливает контекст для следующей задачи.
5.	Запускает эту задачу.
Эти пять шагов алгоритма также называются переключением задач

# 33. Ядро с модульной архитектурой

Модульное ядро — это современная, усовершенствованная модификация архитектуры монолитных ядер операционных систем компьютеров.

Модульные ядра предоставляют механизм подгрузки модулей ядра, поддерживающих аппаратное обеспечение (например, драйверов). При этом подгрузка модулей как динамическая (==выполняемая «на лету»==, без перезагрузки ОС, в работающей системе), так и статической (==выполняемой при перезагрузке ОС== после переконфигурирования системы на загрузку тех или иных модулей).

![](file:///C:/Users/Admin/AppData/Local/Packages/oice_16_974fa576_32c1d314_2873/AC/Temp/msohtmlclip1/01/clip_image002.jpg)

Микроядро управляет взаимодействием всех систем и обеспечивает непрерывность кода системы 
Есть недостатки, среди которых API реализован на ассемблере. Но из положительного - модульность

ИЛИ

==Плюсы: модульные ядра удобнее для разработки==, чем традиционные монолитные ядра, не поддерживающие динамическую загрузку модулей, ==так как не требуется многократная полная перекомпиляция ядра при работе над какой-либо его подсистемой или драйвером.==

==Минусы: не любая программа может быть сделана модулем ядра из-за  определенных ограничений в части используемых функций== (например, ==нельзя пользоваться функциями стандартной библиотеки С/С++== и нужно использовать специальные аналоги, являющиеся функциями API ядра)

------- 
Модульное ядро — современная, усовершенствованная модификация архитектуры монолитных ядер операционных систем компьютеров.

В отличие от «классических» монолитных ядер, модульные ядра не требуют полной перекомпиляции ядра при изменении состава аппаратного обеспечения компьютера. Вместо этого модульные ядра предоставляют тот или иной механизм подгрузки модулей ядра, поддерживающих то или иное аппаратное обеспечение (например, драйверов). При этом подгрузка модулей может быть как динамической (выполняемой «на лету», без перезагрузки ОС, в работающей системе), так и статической (выполняемой при перезагрузке ОС после переконфигурирования системы на загрузку тех или иных модулей).

Достоинства: модульные ядра удобнее для разработки, чем традиционные монолитные ядра, не поддерживающие динамическую загрузку модулей, так как от разработчика не требуется многократная полная перекомпиляция ядра при работе над какой-либо его подсистемой или драйвером. Выявление, локализация, отладка и устранение ошибок при тестировании также облегчаются.

Недостатки: в свою очередь, не любая программа может быть сделана модулем ядра: на модули ядра накладываются определенные ограничения в части используемых функций (например, они не могут пользоваться функциями стандартной библиотеки С/С++ и должны использовать специальные аналоги, являющиеся функциями API ядра)

![](file:///C:/Users/Admin/AppData/Local/Packages/oice_16_974fa576_32c1d314_2873/AC/Temp/msohtmlclip1/01/clip_image002.jpg)

Роль API сводится к тому, чтобы обеспечить связь прикладных процессов и спец. модуля – менеджер задач. Попытка убрать узкие места в API, для упрощения портируемости.

**Микроядро играет двойную роль:**

· Управляет взаимодействием всех систем

· Обеспечивает непрерывность кода системы

**Недостатки** остались такими же, на проблемы перешли с уровня API на уровень микроядра:

· Сократилось время пребывания в этом состоянии за счет уменьшения кода

· API реализован только на ассемблере

**Положительное**: модульность

# 34. Ядро на основе микроядра
Микроядро - это ядро операционной системы, реализующее минимальный набор функций. Работа с микроядром осуществляется также, как и с монолитным ядром — через системные вызовы.

Микроядра предоставляют низкоуровневые механизмы для:
* управления физической и виртуальной памятью компьютера посредством выделения памяти процессам
* управления процессорным временем (планировщик/шедулинг [[#32 Планировщик ОСРВ | планировщик ОСРВ]])
* управления доступом к устройствам ввода/вывода
* коммуникации и синхронизации процессов 

==Преимущества:== простота реализации и откладки, безопасность, надежность, модульность.
Недостатки: низкая производительность и сложность проектирования.
Особенность: в архитектуре нет API, так как вызываются обычные функции с возможностью переключения с задачи на задачу в любое время. Роль API играет компилятор и редактор объектных связей (Linker). Linker загружает только нужные ядра. 

Если микроядро уже загружено для другого приложения, то оно повторно не загружается, а использует код и данные уже имеющегося ядра (повторная входимость кода или реентерабельность). Позволяет снизить объем требуемой памяти.

![](file:///C:/Users/Admin/AppData/Local/Packages/oice_16_974fa576_32c1d314_2873/AC/Temp/msohtmlclip1/01/clip_image002.jpg)

**Примеры ОС на основе Микроядра** Операционная система QNX Neutrino Realtime Operating System (RTOS) [QNXNeutrino] корпорации QNX Software Systems является микроядерной операционной системой, которая обеспечивает многозадачный режим с приоритетами. QNX Neutrino RTOS имеет клиент-серверную архитектуру Как истинная микроядерная ОС QNX Neutrino RTOS реализует только наиболее фундаментальные сервисы в ядре ОС: передача сообщений, сигналы, таймеры, планирование потоков, объекты синхронизации.

-----
Микроядро (англ. microkernel) или μ-ядро (англ. μ‑kernel) — ядро операционной системы, реализующее минимальный набор функций.

Устройство: Работа с микроядром осуществляется так же, как и с монолитным ядром — через системные вызовы.

Микроядра предоставляют лишь небольшой набор низкоуровневых примитивов/механизмов/сервисов для:
●	управления физической и виртуальной памятью компьютера (выделение памяти процессам, обеспечение её изоляции/защиты);
●	управления процессорным временем (сервисы для работы с потоками (нитями) процессов (см. планировщик потоков (англ. scheduling));
●	управления доступом к устройствам ввода-вывода (открытие/закрытие доступа к портам ввода-вывода и MMIO-памяти устройств);
●	коммуникации и синхронизации процессов (англ. inter process communications, IPC) (управляемое и контролируемое нарушение изоляции памяти процесса для организации обмена данными).
Остальные примитивы/функции/компоненты/сервисы/модули, например:
●	драйверы устройств;
●	реализации файловых систем;
●	стеки TCP/IP, USB и др.
работают в пространстве пользователя в виде отдельных процессов, взаимодействуют с ядром с помощью системных вызовов, взаимодействуют друг с другом с помощью IPC. В операционной системе с монолитным ядром эти компоненты работают в пространстве ядра в виде потоков ядра.
На процессорах архитектуры x86 используется так называемая кольцевая защита. Процессы пространства пользователя работают на третьем кольце (англ. ring 3), не могут выполнять некоторые действия, доступные на нулевом кольце (англ. ring 0). Ошибка в процессе пространства пользователя в худшем случае приведёт к завершению процесса.

Преимущества ОС, построенной на микроядре, по сравнению с ОС, построенной на монолитном ядре:
●	простота реализации (ядро и компоненты реализуют чётко определённую функциональность, поэтому размер их кода невелик);
●	простота отладки (компоненты — обычные процессы, поэтому могут отлаживаться с помощью инструментов, созданных для отладки процессов);
●	гарантированная безопасность (код небольшого размера можно проверить на корректность вручную или автоматически — с помощью математических рассуждений);
●	надёжность (в ОС с микроядерной архитектурой ошибка в одном из компонентов приведёт к завершению процесса компонента; в ОС с монолитным ядром отказ компонента приведёт к отказу ОС);
●	модульность (в микроядерной ОС большее число компонентов может быть запущено и остановлено по необходимости; например, для исправления ошибки можно внести изменения в код компонента, скомпилировать новый компонент, остановить старый и запустить новый).

Недостатки ОС, построенной на микроядре, по сравнению с ОС, построенной на монолитном ядре:
●	более низкая производительность (из-за накладных расходов на IPC).
Для того, чтобы микроядерная ОС по скорости не уступала ОС, построенной на базе монолитного ядра, требуется очень аккуратно проектировать разбиение системы на компоненты и стараться минимизировать взаимодействие между ними. Таким образом, основная сложность при создании микроядерных ОС — необходимость очень аккуратного проектирования.
 

==**Ядро**== — это самый маленький и центральный компонент операционной системы. Его услуги включают в себя управление памятью и устройствами, а также предоставление интерфейса программным приложениям для использования ресурсов.

![](file:///C:/Users/Admin/AppData/Local/Packages/oice_16_974fa576_32c1d314_2873/AC/Temp/msohtmlclip1/01/clip_image002.jpg)

В этой архитектуре API нет вообще. Осуществляется взаимодействие между компонентами системы микроядра и пользовательскими процессами не с помощью API, а посредством обычных вызовов функций, так как сама система и приложения написаны на языке С++, следовательно обеспечивает максимальную скорость выполнения. В результате такой архитектуры, соответственно можем переключаться с задачи на задачу в любое время.

**Положительное:**

· В любой момент запускается любая задача

· Модульность

· Безопасность

· Наследование.

Роль API играет компилятор и редактор объектных связей (Linker). Linker загружает только нужные ядра.

Если микроядро уже загружено для другого приложения, то оно повторно не загружается, а использует код и данные уже имеющегося ядра (повторная входимость кода или реентерабельность). Позволяет снизить объем требуемой памяти.

**Примеры ОС на основе Микроядра** Операционная система QNX Neutrino Realtime Operating System (RTOS) [QNXNeutrino] корпорации QNX Software Systems является микроядерной операционной системой, которая обеспечивает многозадачный режим с приоритетами. QNX Neutrino RTOS имеет клиент-серверную архитектуру Как истинная микроядерная ОС QNX Neutrino RTOS реализует только наиболее фундаментальные сервисы в ядре ОС: передача сообщений, сигналы, таймеры, планирование потоков, объекты синхронизации.


# 35. Экзоядро
**ОСРВ с Экзоядром** - это концепция предоставляющая приложению эффективный контроль над оборудованием. Оно запускает только службы, защищающие ресурсы (т. е. отслеживание владения, защита использования, отзыв доступа к ресурсам и т. д.), предоставляя низкоуровневый интерфейс для библиотечных операционных систем (libOSes) и оставляя управление приложению

**![](file:///C:/Users/Admin/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif)**

**Экзоядро** — это ядро операционной систем, предоставляющее лишь функции для взаимодействия между процессами и безопасного выделения и освобождения ресурсов.
	
----
**Экзоядро** — [ядро операционной системы](https://ru.wikipedia.org/wiki/%D0%AF%D0%B4%D1%80%D0%BE_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%BE%D0%B9_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B), предоставляющее лишь функции для взаимодействия между [процессами](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)) и безопасного выделения и освобождения ресурсов.

В традиционных операционных системах ядро предоставляет не только минимальный набор служб, обеспечивающих выполнение [программ](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%BD%D0%B0%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0), но и большое количество высокоуровневых абстракций для использования разнородных ресурсов компьютера: [оперативной памяти](https://ru.wikipedia.org/wiki/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C), [блочных устройств](https://ru.wikipedia.org/wiki/%D0%91%D0%BB%D0%BE%D1%87%D0%BD%D0%BE%D0%B5_%D1%83%D1%81%D1%82%D1%80%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%BE), [сетевых подключений](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%BD%D0%B0%D1%8F_%D1%81%D0%B5%D1%82%D1%8C). В отличие от них, система на основе экзоядра предоставляет лишь набор служб для взаимодействия между приложениями, а также необходимый минимум функций, связанных с защитой: выделение и высвобождение ресурсов, контроль прав доступа и так далее. Экзоядро не занимается предоставлением абстракций для физических ресурсов — эти функции выносятся в библиотеку пользовательского уровня (так называемую libOS).

Основная идея операционной системы на основе экзоядра состоит в том, что ядро должно выполнять лишь функции координатора для небольших процессов, связанных только одним ограничением — экзоядро должно иметь возможность гарантировать безопасное выделение и освобождение ресурсов оборудования.

Архитектуры на основе экзоядер являются дальнейшим развитием и усовершенствованием [микроядерных](https://ru.wikipedia.org/wiki/%D0%9C%D0%B8%D0%BA%D1%80%D0%BE%D1%8F%D0%B4%D1%80%D0%BE) архитектур и одновременно ужесточают требования к минималистичности и простоте кода ядра. В отличие от систем на основе [микроядра](https://ru.wikipedia.org/wiki/%D0%9C%D0%B8%D0%BA%D1%80%D0%BE%D1%8F%D0%B4%D1%80%D0%BE), экзоядерные системы обеспечивают гораздо большую эффективность за счёт отсутствия необходимости в переключении между процессами при каждом обращении к оборудованию.

libOS может обеспечивать произвольный набор абстракций, совместимый с той или иной уже существующей операционной системой, например [Linux](https://ru.wikipedia.org/wiki/Linux) или [Windows](https://ru.wikipedia.org/wiki/Windows).


# 36. Синхронная и асинхронная работа системы 
Синхронные действия процесса – те, которые выполняются в основном потоке, в рамках одного экземпляра процесса. Ключевое отличие синхронного режима: следующее действие начинается только тогда, когда завершено предыдущее. Соответственно, пока одно действие не завершено, процесс стоит колом.

Асинхронные действия – те, которые выполняются параллельно основному потоку, либо в том же экземпляре процесса, либо вообще в другом процессе. Ключевое отличие асинхронного режима: параллельное выполнение двух и более ветвей процесса.

![[ЛК_Вычислительные_системы_реального_времени-3.pdf]]

# 37.	Стандарты ОСРВ. Семейство стандартов POSIX 
          

Стандарт **ARINC-653** (Avionics Application Software Standard Interface) разработан компанией ARINC в 1997 г. Этот стандарт определяет универсальный программный интерфейс APEX (Application/Executive) между ОС авиационного компьютера и прикладным ПО

Стандарт **OSEK/VDX** является комбинацией стандартов, которые изначально разрабатывались в двух отдельных консорциумах, впоследствии слившихся. OSEK берет свое название от немецкого акронима консорциума, в состав которого входили ведущие немецкие производители автомобилей – BMW, Bosch, Daimler Benz (теперь Daimler Chrysler), Opel, Siemens и Volkswagen, а также университет в Карлсруэ (Германия).

Стандарт **DO-178B**, создан Радиотехнической комиссией по аэронавтике (RTCA, Radio Technical Commission for Aeronautics) для разработки ПО бортовых авиационных систем [DO178B]. Первая его версия была принята в 1982 г., вторая (DO-178A) - в 1985-м, текущая DO-178B - в 1992 г. Готовится принятие новой версии, DO-178C.

Стандарт **POSIX** был создан как стандартный интерфейс сервисов операционных систем. Этот стандарт дает возможность создавать переносимые приложения. Впоследствии этот стандарт был расширен особенностями режима реального времени [POSIX].

Спецификации **POSIX** задают стандартный механизм взаимодействия приложения и ОС. Необходимо отметить, что стандарт **POSIX** тесно связан с ОС Unix; тем не менее, разработчики многих ОСРВ стараются выдержать соответствие этому стандарту. Соответствие стандарту **POSIX** для ОС и аппаратной платформы должно быть сертифицировано с помощью прогона на них тестовых наборов [POSIXTestSuite]. Однако, если ОС не является Unix-подобной, выдержать это требование становится непростой задачей. Тестовые наборы существуют только для POSIX 1003.1a. Поскольку структура POSIX является совокупностью необязательных возможностей, поставщики ОС могут реализовать только часть стандартного интерфейса, и при этом говорить о POSIX-комплиантности своей системы.

Несмотря на то, что стандарт POSIX вырос из Unix’а, он затрагивает основополагающие абстракции операционных систем, а расширения реального времени применимы ко всем ОСРВ.

К настоящему времени стандарт **POSIX** рассматривается как семейство родственных стандартов: IEEE Std 1003.n (где n – это номер).


# 38. Процесс POSIX
Напомним данное в стандарте POSIX-2001 определение процесса. **Процесс** – это адресное пространство вместе с выполняемыми в нем потоками управления, а также системными ресурсами, которые этим потокам требуются.

Каждый процесс обладает целым рядом атрибутов. Важнейшим среди них является **идентификатор процесса** – положительное целое число, однозначно идентифицирующее процесс в течение времени его жизни.

Процессы могут создаваться и завершаться. **Время жизни процесса** – это период от его создания до возврата идентификатора операционной системе.

После того как процесс создан с помощью функции fork(), он считается активным. До завершения процесса в его рамках существуют по крайней мере один поток управления и адресное пространство.

Процесс может перейти в неактивное состояние, и тогда некоторые из его ресурсов (но не идентификатор) могут быть возвращены системе. Когда по отношению к неактивному процессу выполняют функцию семейства wait(), системе возвращаются остальные ресурсы. Последний из них – идентификатор процесса, и на этом время жизни процесса заканчивается.

Завершение процесса может быть нормальным или аварийным. Нормальное завершение происходит, в частности, при возврате из функции main().

---
# 39. Диаграмма состояний процесса и приоритет процесса  
            

![](file:///C:/Users/Admin/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif)

![](file:///C:/Users/Admin/AppData/Local/Temp/msohtmlclip1/01/clip_image004.gif)

# 40. Поток POSIX

POSIX Threads — стандарт POSIX-реализации потоков (нитей) выполнения. Стандарт POSIX.1c, Threads extensions (IEEE Std 1003.1c-1995) определяет API для управления потоками, их синхронизации и планирования.

Реализации данного API существуют для большого числа UNIX-подобных ОС (GNU/Linux, Solaris, FreeBSD, OpenBSD, NetBSD, OS X), а также для Microsoft Windows и других ОС.

Библиотеки, реализующие этот стандарт (и функции этого стандарта), обычно называются Pthreads (функции имеют приставку «pthread_»).

Что такое нить? Нить — это программный поток запущенный в рамках контекста процесса. Контекст нити гораздо меньше контекста потока, следовательно переключение нити работает гораздо быстрее, так как нить выполняется в рамках контекста процесса. Процесс может запускать несколько нитей и ждать окончания их выполнения. В рамках одного процесса реализуются несколько нитей.
Нити связаны с исполнением функций. Нить можно рассматривать по отношению к функции в том же качестве как процесс и программу. Мы будем понимать нить как среду, в которой будет выполняться функция

-----
        
**POSIX Threads** — стандарт [POSIX](https://ru.wikipedia.org/wiki/POSIX)-реализации [потоков (нитей) выполнения](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%82%D0%BE%D0%BA_%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F). Стандарт _POSIX.1c, Threads extensions (__[IEEE](https://ru.wikipedia.org/wiki/IEEE)_ _Std 1003.1c-1995)_ определяет [API](https://ru.wikipedia.org/wiki/API) для управления потоками, их синхронизации и планирования.

Реализации данного API существуют для большого числа [UNIX](https://ru.wikipedia.org/wiki/UNIX)-подобных ОС ([GNU/Linux](https://ru.wikipedia.org/wiki/GNU/Linux), [Solaris](https://ru.wikipedia.org/wiki/Solaris), [FreeBSD](https://ru.wikipedia.org/wiki/FreeBSD), [OpenBSD](https://ru.wikipedia.org/wiki/OpenBSD), [NetBSD](https://ru.wikipedia.org/wiki/NetBSD), [OS X](https://ru.wikipedia.org/wiki/OS_X)), а также для [Microsoft Windows](https://ru.wikipedia.org/wiki/Microsoft_Windows) и других ОС.

Библиотеки, реализующие этот стандарт (и функции этого стандарта), обычно называются **Pthreads** (функции имеют приставку «pthread_»).

[https://ru.wikipedia.org/wiki/POSIX_Threads](https://ru.wikipedia.org/wiki/POSIX_Threads)

**Поток (thread)** – это запускаемый из некоторого процесса особого рода параллельный процесс, выполняемый в том же адресном пространстве, что и процесс-родитель. Схема организации однопоточного и многопоточного процессов изображена на

![[Pasted image 20220125213614.png]]

Как видно из схемы, однопоточный процесс использует, как обычно, код, данные в основной памяти и файлы, с которыми он работает. Процесс также использует определенные значения регистров и стек, на котором исполняются его процедуры. Многопоточный процесс организован несколько сложнее. Он имеет несколько параллельных потоков, для каждого из которых ОС создает свой стек и хранит свои собственные значения регистров. Потоки работают в общей основной памяти и используют то же адресное пространство, что и процесс-родитель, а также разделяют код процесса и файлы.

[https://intuit.ru/studies/courses/641/497/lecture/11284?page=1](https://intuit.ru/studies/courses/641/497/lecture/11284?page=1)

В качестве конкретной модели многопоточности рассмотрим потоки POSIX (напомним, что данная аббревиатура расшифровывается как **Portable Operating Systems Interface of uniX kind** – стандарты для переносимых ОС типа UNIX). Многопоточность в POSIX специфицирована стандартом IEEE 1003.1c, который описывает API для создания и синхронизации потоков. Отметим, что POSIX-стандарт API определяет лишь требуемое поведение библиотеки потоков. Реализация потоков оставляется на усмотрение авторов конкретной POSIX-совместимой библиотеки. POSIX-потоки распространены в ОС типа UNIX, а также поддержаны, с целью совместимости программ, во многих других ОС, например, Solaris и Windows NT.

Стандарт POSIX определяет два основных типа данных для потоков: **pthread_t – дескриптор потока** ; **pthread_attr_t – набор атрибутов потока**.

Стандарт POSIX специфицирует следующий набор функций для управления потоками:

 pthread_create(): создание потока

 pthread_exit():завершение потока (должна вызываться функцией потока при завершении)

 pthread_cancel():отмена потока

 pthread_join():заблокировать выполнение потока до прекращения другого потока, указанного в вызове функции

 pthread_detach():освободить ресурсы занимаемые потоком (если поток выполняется, то освобождение ресурсов произойдёт после его завершения)

 pthread_attr_init():инициализировать структуру атрибутов потока

 pthread_attr_setdetachstate():указать системе, что после завершения потока она может автоматически освободить ресурсы, занимаемые потоком

pthread_attr_destroy():освободить память от структуры атрибутов потока (уничтожить дескриптор).

# 41.	Понятие процесса и способы его описания 
          
Термин «процесс» впервые появился при разработке операционной системы Multix и имеет несколько определений, которые используются в зависимости от контекста, согласно которым **процесс** — это:

программа на стадии выполнения

«объект», которому выделено процессорное время

асинхронная работа

Для описания состояний процессов используется несколько моделей. Самая простая — модель трех состояний (рис. 1). Она определяет следующие состояния процесса:

состояния выполнения

состояния ожидания

состояния готовности

**Выполнение** — это _активное состояние_, во время которого процесс обладает всеми необходимыми ему ресурсами. В этом состоянии процесс непосредственно выполняется процессором.

**Ожидание** — это _пассивное состояние_, во время которого процесс заблокирован и не может быть выполнен, потому что ожидает какое-то событие, например, ввода данных или освобождения нужного ему устройства.

**Готовность** — это тоже пассивное состояние, процесс тоже заблокирован, но в отличие от состояния ожидания, он заблокирован не по внутренним причинам (ведь ожидание ввода данных — это внутренняя, «личная» проблема процесса — он может ведь и не ожидать ввода данных и свободно выполняться — никто ему не мешает), а по внешним, независящим от процесса, причинам.

-----
          
Процесс – это исполняемая копия приложения. Например, когда вы открываете приложение MS Word, то запускаете процесс, исполняющий программу MS Word. Поток – отдельное исполняемое задание внутри процесса. Процесс может содержать множество исполняемых потоков. После запуска приложения исполняется главный поток, который далее может порождать другие потоки.

Каждый процесс обладает собственной памятью. Потоки же, которые запущены внутри процесса, разделяют память между собой. Процесс внутри операционной системы обладает собственным идентификатором. Потоки существуют внутри процесса и обладают идентификатором внутри работающего приложения. Каждый из потоков имеет свой собственный стек (он не делит его с другими потоками и другие потоки не могут в него залезть) и собственный набор регистров (поток не изменит значения регистра другого потока во время работы). Часто потоки называют «легковесными» процессами, так как они требуют гораздо меньше ресурсов для работы, чем новый процесс. В зависимости от реализации, обычный настольный компьютер может эффективно использовать от единиц, до десятков тысяч потоков.

**Процесс**

● Идентификатор процесса

● Окружение

● Рабочая папка

● Регистры

● Стек

● Куча

● Файловый дескриптор

● Общие библиотеки (dll, so)

● Инструменты межпроцессорного взаимодействия (пайпы, очереди сообщений, семафоры или обобщённая память)

● Специфические для операционной системы ресурсы

**Поток**

● Stack Pointer (указатель на вершину стека, на самом деле «своего» стека, как у процесса, у потока нет)

● Регистры

● Свойства (необходимые для планировщика, такие как приоритет или политики)

● Специфичные для потока данные

● Специфические для операционной системы ресурсы

[https://learnc.info/c/processes_and_threads.html](https://learnc.info/c/processes_and_threads.html)

In [POSIX](https://www.lynx.com/embedded-systems-learning-center/benefits-of-posix?hsLang=en), an executing instance of a program is called a process. To be conformant with the POSIX standard, processes must be kept separate through the use of memory protection. An operating system (OS) that supports multiple processes is referred to as a “multiprocessing” OS.

В POSIX блок исполнения программы называется процессом. Чтобы соответствовать стандарту, процессы должны быть изолированы использованием защиты памяти. ОС поддерживающая несколько процессов одновременно называется многопроцессорной


# 42.Системный вызов fork() POSIX
          
Fork() - это системный вызов, который создает новый процесс в операционной системе UNIX. Его цель - создать новый процесс, который становится дочерним процессом вызывающего. После создания нового дочернего процесса оба процесса выполнят инструкцию, следующую за системным вызовом fork().

Для отличия родительского процесса от дочернего возможно проверить возвращаемое значение fork():

● при возврате отрицательного значения создание дочернего процесса не удалось;

● fork() возвращает ноль вновь созданному дочернему процессу в качестве кода возврата;

● fork() возвращает положительное значение, идентификатор дочернего процесса родительскому процессу.

Возвращаемый идентификатор процесса имеет тип pid_t, определенный в sys/types.h.

Unix делает точную копию адресного пространства родителя и передает его потомку, следовательно родительский и дочерний процессы имеют разные адресные пространства.

-----
          

Новые процессы создаются при помощи функции fork() (см. [листинг 7.20](https://intuit.ru/studies/courses/47/47/lecture/1409?page=5#example.7.20)).

#include <unistd.h>
pid_t fork (void);
Листинг 7.20. Описание функции fork().

Новый (порожденный) процесс является точной копией процесса, вызвавшего fork() (родительского), за исключением следующих моментов.

1. У порожденного процесса свой идентификатор, равно как и идентификатор родительского процесса.

2. У порожденного процесса собственная копия файловых дескрипторов, ссылающихся на те же описания открытых файлов, что и соответствующие дескрипторы родительского процесса.

3. Порожденный процесс не наследует блокировки файлов, установленные родительским процессом.

4. Порожденный процесс создается с одним потоком управления – копией того, что вызвал fork().

5. Имеются также некоторые тонкости, связанные с обработкой сигналов, на которых мы, однако, останавливаться не будем.

В случае успешного завершения функция fork() возвращает порожденному процессу 0, а родительскому процессу – идентификатор порожденного процесса. После этого оба процесса начинают независимо выполнять инструкции, расположенные за обращением к fork(). При неудаче родительскому процессу возвращается -1, новый процесс не создается.

Поскольку возвращаемые функцией fork() значения различны для обеих копий, родительский и порожденный процессы могут далее выполняться по-разному. Например, процесс-предок переходит в состояние ожидания завершения процесса-потомка либо, если процесс-потомок запущен асинхронно, продолжает выполнение параллельно с ним. Процесс-потомок при помощи функции семейства exec() подменяет программу, которая определяет поведение процесса, и передает ей управление и список аргументов.

https://intuit.ru/studies/courses/47/47/lecture/1409?page=5

# 43.Системный вызов exec() POSIX 

Вызов **exec()** заменяет пользовательский контекст текущего процесса на содержимое некоторого исполняемого файла и устанавливает начальные значения регистров процессора (в том числе устанавливает программный счетчик на начало загружаемой программы). Этот вызов требует для своей работы задания имени исполняемого файла, аргументов командной строки и параметров окружающей среды. Для осуществления вызова программист может воспользоваться одной из шести функций: execlp() , execvp() , execl() и, execv() , execle() , execve() , отличающихся друг от друга представлением параметров, необходимых для работы системного вызова exec() .

-----
Напомним, что заголовок функции main() C-программы выглядит в общем случае так, как показано в [листинге 7.21](https://intuit.ru/studies/courses/47/47/lecture/1409?page=5#example.7.21).

int main (int argc, char *argv []);

7.21. Заголовок функции main() C-программы.

Значение argc равно количеству аргументов; argv – это массив указателей собственно на аргументы, которые определяются исходя из командной строки, запускающей C-программу. В соответствии с принятым соглашением, значение argc не меньше единицы, а первый элемент массива argv указывает на цепочку символов, содержащую имя выполняемого файла.

Аналогичный смысл имеют аргументы функций семейства exec() (см. [листинг 7.22](https://intuit.ru/studies/courses/47/47/lecture/1409?page=5#example.7.22)).

#include <unistd.h>

extern char **environ;

int execl (const char *path, const char *arg0, ...

 /*, (char *) 0 */);

int execv (const char *path, char *const argv []);

int execle (const char *path, const char *arg0,

 ... /*, (char *) 0, char *const envp [] */);

int execve (const char *path, char *const argv [],

 char *const envp []);

int execlp (const char *file, const char *arg0,

 ... /*, (char *) 0 */);

int execvp (const char *file, char *const argv []);

7.22. Описание функций семейства exec().

Функции семейства exec() заменяют текущий образ процесса новым (и, следовательно, в случае успешного завершения возврат в вызывающий процесс невозможен). Новый образ создается на основе выполнимого файла, называемого файлом образа процесса.

Переменная environ инициализируется как указатель на массив указателей на составляющие окружение цепочки символов. Массивы argv и environ завершаются пустым указателем.

Аргумент path указывает на маршрутное имя файла с новым образом процесса.

Аргумент file имеет аналогичный смысл, однако, если он задан как простое имя, то производится поиск в каталогах, заданных переменной окружения PATH.

Аргументы arg0, ..., являются указателями на цепочки символов, составляющие список аргументов нового образа процесса. Последним в списке располагается пустой указатель, а аргумент arg0 должен указывать на имя файла-образа.

Аргумент envp имеет тот же смысл и назначение, что и переменная environ.

Файловые дескрипторы остаются открытыми в новом образе, если только они не были снабжены флагом FD_CLOEXEC.

Если у файла с новым образом процесса взведен бит ПДИП, действующий идентификатор пользователя процесса переустанавливается равным идентификатору владельца файла (аналогично для группы).

Следующие атрибуты процесса остаются неизменными:

 идентификатор процесса;

 идентификатор родительского процесса;

 идентификатор группы процессов;

 членство в сеансе;

 реальные идентификаторы пользователя и группы процесса;

 идентификаторы дополнительных групп;

 текущий и корневой каталоги;

 маска режима создания файлов;

 атрибуты, связанные с обработкой сигналов.

[https://intuit.ru/studies/courses/47/47/lecture/1409?page=5](https://intuit.ru/studies/courses/47/47/lecture/1409?page=5)

Тут чуть понятнее [https://www.opennet.ru/docs/RUS/linux_parallel/node8.html](https://www.opennet.ru/docs/RUS/linux_parallel/node8.html)


# 44. Системный вызов dup() и dup2() POSIX

          

Системный вызов **dup()** создает копию дескриптора файла.

Для нового дескриптора используется неиспользуемый дескриптор с наименьшим номером.

Если копия успешно создана, то дескрипторы файла оригинала и копии могут использоваться взаимозаменяемо.

Они оба ссылаются на одно и то же описание открытого файла и, таким образом, совместно используют смещение файла и флаги состояния файла.

Синтаксис:

int dup(int oldfd);

// oldfd: old file descriptor whose copy is to be created.

Системный вызов **dup2()** похож на **dup()**, но основное различие между ними заключается в том, что вместо использования неиспользуемого дескриптора файла с наименьшим номером он использует номер дескриптора, указанный пользователем.

Синтаксис:

int dup2(int oldfd, int newfd);

// oldfd: old file descriptor

// newfd: new file descriptor which is used by dup2() to create a copy

-----
Прототипы:  
int dup(int handle);  
int dup2(int old_handle, int new_handle); Описание:

 Функция dup() возвращает новый дескриптор файла, который полностью описывает (т.е. дуб­лирует) состояние файла, связанного с handle. В случае успеха возвращается неотрицательная величина, а в противном случае —1.

Функция dup2() дублирует old_handle как new_handle. Если имеется файл, который был связан с new_handle до вызова dup2(), то он будет закрыт. В случае успеха возвращается 0, а в случае ошибки —1. При ошибке errno устанавливается в одно из следующих значений:  
а) EMFILE Открыто слишком много файлов  
в) EBADF Недействительный дескриптор файла


# 45.  Понятие прерывания. Роль прерываний в СРВ

Прерывание это программный или аппаратный сигнал процессору Приход прерывания означает следующее: Текущий процесс хочет перейти в состояние sleep или выполнить операцию I/O Диспетчер хочет запустить другую задачу Движение мыши или нажатие клавиатуры Сенсоры обнаружили превышение радиации Процессор часто проверяет прерывания.

Если какое либо пришло, то немедленно выполнение текущей задачи приостанавливается и запускается обработчик прерывания ассоциированный с ним - interrupt service routine, далее (ISR).


 # 46. Понятие события в СРВ. Асинхронные и синхронные события

Внешние события, на которые СРВ должна реагировать можно разделить на 2 категории: 1. Периодические события 2. Не периодические события (апериодические) Периодические события – возникают через регулярные промежутки времени.

Асинхронными событиями являются те, которые возникают независимо от основного потока выполнения программы. Асинхронные действия — действия, выполненные в неблокирующем режиме, что позволяет основному потоку программы продолжить обработку. Синхронные - события с синхронизацией между потоками.

# 47.	 Понятие и виды прерываний
Прерывание — сигнал к процессору , испускаемый аппаратными средствами или программным обеспечением, и указывающий на событие, которое требует немедленного внимания. Прерывание предупреждает процессор о высокоприоритетном состоянии, требующем прерывания текущего кода, выполняемого процессором. Процессор отвечает, приостанавливая свои текущие действия, сохраняя свое состояние и выполняя функцию, называемую обработчиком прерываний (или подпрограммой обработки прерываний, ISR) для обработки события. Это прерывание является временным, и после завершения обработки обработчика прерывания процессор возобновляет обычную работу.

Существует два типа прерываний: аппаратные прерывания и программные прерывания.
Аппаратные прерывания используются устройствами для передачи информации о том, что они требуют внимания со стороны операционной системы.
Программное прерывание вызвано либо исключительным состоянием в самом процессоре, либо специальной инструкцией в наборе команд, которая вызывает прерывание, когда инструкция выполняется.

# 48. Приоритезированные прерывания 
Все прерывания, помимо уровня, также имеют приоритет. При одновременном поступлении запросов от нескольких источников прерываний, очередность их обработки будет определяться с учетом их уровня и приоритета. Приоритезация прерываний может быть статической или динамической (карусельной, round-robin). Приоритезация прерываний высокого и среднего уровней, а также немаскируемых прерываний является только статической, а приоритезация низкоуровневых прерываний может быть как статической, так и динамической (задается пользователем).
  
линк: http://www.gaw.ru/html.cgi/txt/doc/micros/avr/arh_xmega_a/12_6.htm

          

# 49 Отключенные прерывания

Запрещение прерываний/синхронизации - методы для получения исключительного доступа к разделяемым ресурсам. Запрет прерывания разрешает проблему deadlock’а, но не стоит надолго удерживать запрет на прерывание.

# 50 Маскированные прерывания

**_Маскирование прерываний_** используется для сообщения микроконтроллеру о необходимости реагировать на каждый тип прерывания или игнорировать его. **_Маска_** прерывания представляет двоичный код, разряды которого поставлены в соответствие источникам запроса прерываний. Единичный бит в двоичном коде сообщает микроконтроллеру о необходимости обработки прерываний такого типа. Нулевой бит напротив не позволяет микроконтроллеру переходить к обработке прерываний указанного типа.

Как правило, кроме маскирования прерываний, существует также бит глобального разрешения прерываний, нулевое значение которого отключает все обработчики прерываний (кроме аппаратного сброса и перехода к началу исполняемой программы).

Кроме двоичного кода маски прерываний существует также двоичный код **_флагов прерываний_**, который позволяет обработчику прерываний установить источник возникновения прерывания в случае если источников с указанным запросом в микроконтроллере несколько.

[https://prog-cpp.ru/micro-interrupts/](https://prog-cpp.ru/micro-interrupts/)

-----
_Маскирование прерываний_ используется для сообщения микроконтроллеру о необходимости реагировать на каждый тип прерывания или игнорировать его. _Маска_ прерывания представляет двоичный код, разряды которого поставлены в соответствие источникам запроса прерываний. Единичный бит в двоичном коде сообщает микроконтроллеру о необходимости обработки прерываний такого типа. Нулевой бит напротив не позволяет микроконтроллеру переходить к обработке прерываний указанного типа.

# 51.Понятие процесса в теории Вычислительных процессов и систем 
          

Определения термина «процесс» Термин «процесс» впервые начали применять разработчики системы MULTICS в 60-х годах. За прошедшее время термин «процесс», используемый в ряде случаев как синоним «задачи», получил много различных определений. Мы приведем здесь некоторые из них:

• программа в стадии выполнения;

• асинхронная работа;

• «живая душа» процедуры;

• «концентрация средств управления» для выполняемой процедуры;

• нечто, представленное в виде «блока управления процессом» в операционной системе; • объект, которому выделяются процессоры;

• «диспетчируемый» модуль.

Встречаются и многие другие определения. Таким образом, общепринятого определения пока нет, однако чаще всего, по-видимому, под процессом понимается «программа во время выполнения». 

[http://po-02-1.narod.ru/files/edu/lek/tvp.pdf](http://po-02-1.narod.ru/files/edu/lek/tvp.pdf)


# 52.Дерево процессов
Когда мы запускаем любую программу, выполняется необходимый процесс (называется родительский), который может запускать в случае необходимости другие процессы (дочерние). Так возникает дерево процессов.


# 53.Процесс в СРВ и его жизненный цикл 
Процесс - задача
ЖЦ - момент создания задачи - всякая хуйня - момент уничтожения задачи
(простите я нихуя не нашел)


# 54.Описание процесса
          

_П_роцесс – это исполняемая копия приложения. Например, когда вы открываете приложение MS Word, то запускаете процесс, исполняющий программу MS Word. Поток – отдельное исполняемое задание внутри процесса. Процесс может содержать множество исполняемых потоков. После запуска приложения исполняется главный поток, который далее может порождать другие потоки.

Каждый процесс обладает собственной памятью. Потоки же, которые запущены внутри процесса, разделяют память между собой. Процесс внутри операционной системы обладает собственным идентификатором. Потоки существуют внутри процесса и обладают идентификатором внутри работающего приложения. Каждый из потоков имеет свой собственный стек (он не делит его с другими потоками и другие потоки не могут в него залезть) и собственный набор регистров (поток не изменит значения регистра другого потока во время работы). Часто потоки называют «легковесными» процессами, так как они требуют гораздо меньше ресурсов для работы, чем новый процесс. В зависимости от реализации, обычный настольный компьютер может эффективно использовать от единиц, до десятков тысяч потоков.

**Процесс**

● Идентификатор процесса

● Окружение

● Рабочая папка

● Регистры

● Стек

● Куча

● Файловый дескриптор

● Общие библиотеки (dll, so)

● Инструменты межпроцессорного взаимодействия (пайпы, очереди сообщений, семафоры или обобщённая память)

● Специфические для операционной системы ресурсы

**Поток**

● Stack Pointer (указатель на вершину стека, на самом деле «своего» стека, как у процесса, у потока нет)

● Регистры

● Свойства (необходимые для планировщика, такие как приоритет или политики)

● Специфичные для потока данные

● Специфические для операционной системы ресурсы

[https://learnc.info/c/processes_and_threads.html](https://learnc.info/c/processes_and_threads.html)

In [POSIX](https://www.lynx.com/embedded-systems-learning-center/benefits-of-posix?hsLang=en), an executing instance of a program is called a process. To be conformant with the POSIX standard, processes must be kept separate through the use of memory protection. An operating system (OS) that supports multiple processes is referred to as a “multiprocessing” OS.

В POSIX блок исполнения программы называется процессом. Чтобы соответствовать стандарту, процессы должны быть изолированы использованием защиты памяти. ОС поддерживающая несколько процессов одновременно называется многопроцессорной


---
Поис по процессу сделай, вопрос такой был


# 55.Понятие нити (thread) или подпроцесса в СРВ 
Что такое нить? Нить — это программный поток запущенный в рамках контекста процесса. Контекст нити гораздо меньше контекста потока, следовательно переключение нити работает гораздо быстрее, так как нить выполняется в рамках контекста процесса. Процесс может запускать несколько нитей и ждать окончания их выполнения. В рамках одного процесса реализуются несколько нитей. 

# 56.Описание нити в *NIX системах
Фактически, потоки в Linux реализованы, как «легковесные процессы». Другими словами со стороны ядра linux нет чёткого разграничения между оными: все они представляются в ядре, как задачи task_struct, при этом, например, task->mm указывает на дескриптор адресного пространства (mm_struct), а task->files на таблицу файловых дескрипторов (files_struct) и для ОСРВпрерыанияпотоков одного процесса оба эти указателя будут просто указывать на один объект. ИМХО прежде всего это сделано в силу исторических причин, хотя такая реализация и не лишена своей красоты.


# 57.Планировщик процессов и его роль 
Планирование - обеспечение поочередного доступа процессов к одному процессору.
Планировщик - отвечающая за это часть операционной системы.
Алгоритм планирования - используемый алгоритм для планирования.
Ситуации, когда необходимо планирование:
1.	Когда создается процесс
2.	Когда процесс завершает работу
3.	Когда процесс блокируется на операции ввода/вывода, семафоре, и т.д.
4.	При прерывании ввода/вывода


# 58.Диспетчер процессов и его роль 
Диспетчер процессора – компонента ОС, предоставляющая ресурсы системы тому процессу, который был выбран планировщиком. Диспетчер выполняет последовательность действий:
●	Переключает контекст
●	Переключает процессор в пользовательский режим
●	Выполняет переход по соответствующему адресу в пользовательскую программу для ее рестарта.


# 59.Алгоритмы планирования и диспетчеризации 
Существуют два основных для СРВ вида алгоритмов планирования запуска процессов: 
1.	Статический алгоритм. Статические алгоритмы задают приемлемый план выполнения заданий по их априорным характеристикам. Примером статического алгоритма является алгоритм RMS - Rate Monotonic Sheduling,  
2.	Динамический алгоритм. Динамический алгоритм позволяет изменять план во время выполнения задания или процесса. Примером динамического алгоритма является алгоритм EDF. Earliest Deadline First или кратко EDF переводится как Алгоритм планирования по ближайшему сроку завершения


# 60.Алгоритм FCFS
            

**Стратегия First-Come-First-Served (обслуживание в порядке поступления)** – наиболее простая стратегия диспетчеризации, при которой ресурсы процессора предоставляются процессам в порядке их поступления (ввода) в систему, независимо от потребляемых ими ресурсов, в частности, от заявленного процессом времени, требуемого для его выполнения. При рассмотрении этой и других стратегий будем использовать **диаграммы Ганта (Gantt charts** изображающие имена процессов и временные диапазоны их выполнения, выраженные в некоторых единицах времени.

Рассмотрим следующий пример. Пусть процессы P1, P2 и P3 введены в систему в указанном порядке со следующими периодами активности:

![](file:///C:/Users/Admin/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif)

Тогда при использовании стратегии FCFS для их диспетчеризации первым получит процессор первый процесс, несмотря на то, что он – наиболее долгий.

![](file:///C:/Users/Admin/AppData/Local/Temp/msohtmlclip1/01/clip_image004.gif)

Таким образом, время ожидания для P1 = 0; P2= 24; P3 = 27.

Среднее время ожидания: (0 + 24 + 27)/3 = 17.

ИМХО: настоящие пацаны и пацанессы пускают сначала короткие процессы первыми

# 61.  Статические алгоритмы планирования (RMS — rate monotonic schedule): принцип работы
            

Статические алгоритмы задают приемлемый план выполнения заданий по их априорным характеристикам.

Примером статического алгоритма является алгоритм RMS - Rate Monotonic Sheduling.

Для статических алгоритмов рассчитываются приоритеты процессов, обрабатывающих появление события на объекте пропорционально частоте времени появления события. И назначенный приоритет не может изменяться.

**_Положительное:_** Небольшие накладные расходы

**_Отрицательное:_** Алгоритм RMS может использовать только в том случае, если загруженность ЦП не велика.

Классическим примером статического алгоритма планирования, является алгоритм RMS. Этот алгоритм используется только для процессов, удовлетворяющих условиям:

1. Каждый периодический процесс должен быть завершен за время своего периода.

2. Процесс не должен зависеть от любого другого процесса (это не реально)

3. Каждому процессу требуется одинаковое количество времени ЦП на каждом интервале.

4. У непериодических процессов нет жестких сроков по обработке.

5. Прерывание процесса происходит мгновенно без накладных расходов.

![](file:///C:/Users/Admin/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif)

Так как у А – самый высокий приоритет, а во время работы планировщик всегда запускает готовый к работе процесс с самым высоким приоритетом, то выполнения А будет прерывать выполнение В и С.

В момент времени 90 мс (D2) процесс А переходит в состояние готовности, соответственно В прерывается, обрабатывается событие А, а затем процесс В возобновляется.

Если мы увеличиваем А на 5 мс, то процесс А и В работают по очереди, а С пропускает свой критический период, это значит, что алгоритм RMS терпит неудачу.

![](file:///C:/Users/Admin/AppData/Local/Temp/msohtmlclip1/01/clip_image004.gif)


# 62.  Динамические   алгоритмы   планирования   (EDF   — Earliest            	deadline    	first): принцип работы
            

EDF – Earliest Deadline First (Процесс с ближайшим сроком завершения)

Динамический алгоритм позволяет изменять план во время выполнения задания или процесса.

Примером динамического алгоритма является алгоритм EDF. Earliest Deadline First или кратко EDF переводится как Алгоритм планирования по ближайшему сроку завершения.

Для динамических алгоритмов может изменятся приоритет динамически, то есть время выполнения.

Процесс с ближайшим сроком завершения, будет выполняться в первую очередь.

Этот алгоритм не требует периодичности процесса, не требует регулярных временных интервалов использования ЦП.

Каждый раз, когда процессу требуется ЦП, он заявляет о своем присутствии и своем сроке выполнения задания, срок до завершения. Планировщик хранит список процессов, который отсортирован по срокам выполнения заданий. Когда новый процесс приходит в состояние готов, то система сравнивает срок его завершения с текущим процессом, если он меньше, то работа текущего процесса прерывается.

![](file:///C:/Users/Admin/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif)

До момента времени 90 оба алгоритма работают идентично, процесс А переходит в состояние готовности с тем же крайним временем исполнения 120, что и процесс В, поэтому планировщик имеет право выбрать любой из процессов.

Чтобы не было накладных расходов на прерывание, лучше оставить процесс В3 до конца выполнения и затем запустить А4.

Алгоритм EDF работает с любым набором процессов, для которых возможно планирование. Плата за это является использование более сложного алгоритма.

# 63.  Инверсия приоритетов в СРВ. Понятие и причины появления 
          

Инверсия приоритета происходит, когда мьютекс или критический раздел, удерживаемый потоком с более низким приоритетом, задерживает выполнение потока с более высоким приоритетом, когда они оба конкурируют за один и тот же ресурс.

Для ядра РВ предпочтительна система с динамическим приоритетом, чтобы избежать такого нежелательного явления как инверсия приоритета.

Объяснение:

Инверсия приоритетов возникает, когда два потока, высоко приоритетный (В) и низкоприоритетный (Н) разделяют некий общий ресурс (Р). Предположим, также что в системе присутствует третий поток, приоритет которого находится между приоритетами В и Н. Назовем его средним (С).

Если поток В переходит в состояние готовности когда активен поток Н и Н заблокировал ресурс Р, то поток В вытеснит поток Н и Р останется заблокирован. Когда В понадобится ресурс Р, то он сам перейдет в заблокированное состояние.

Если в состоянии готовности находится только поток Н, то ничего страшного не произойдет, Н освободит заблокированный ресурс и будет вытеснен потоком В. Но если на момент блокирования потока В, в состоянии готовности находится поток С, приоритет которого выше чем у Н, то активным станет именно он, а Н опять будет вытеснен, и получит управление только после того, как С закончит свою работу. Подобная задержка вполне может привести к тому, что критическое время обслуживания потока В будет пропущено. Если В это поток жесткого реального времени, то подобная ситуация недопустима

# 64.Виды событий в СРВ: классификация
          

Внешние события, на которые СРВ должна реагировать можно разделить на 2 категории:

1. Периодические события

2. Не периодические события (апериодические)

Периодические события – возникают через регулярные промежутки времени.

Например, задача может войти в блокированное состояние, для ожидания прохождения 10 мс.

В зависимости от времени, которое затрачивается на обработку события, может случиться так, что система будет не в состоянии обработать все события.

Не периодические события или события синхронизации – поступают от другой задачи или от прерывания.

Например, задача может войти в Blocked state для ожидания поступления данных (появления их в очереди).

Для создания событий синхронизации могут использоваться очереди, двоичные семафоры, семафоры со счетчиком, рекурсивные семафоры, мьютексы.

Событие синхронизации с таймаутом – создаются для того, чтобы эффективно обрабатывать оба типа событий (события времени и синхронизации).

Например, задача может ожидать максимум 10 мс события появления данных в очереди. Задача покинет состояние «Blocked» либо при поступлении данных на очереди, либо по истечении 10 мс (что означает таймаут поступления данных).

Примеры событий: прерывание, мьютекс, семафор.

# 65.Мьютексы. Понятие и их использование в СРВ 
          

Мьютекс – это специальный тип двоичного семафора, который используется для управлением доступа к ресурсу, который используется совместно двумя или большим количеством задач. Слово MUTEX произошло от "MUTual EXclusion" (взаимное исключение).

Когда используется сценарий взаимного исключения, мьютекс можно концептуально рассмотреть как токен, связанный с совместно используемым ресурсом. Для законного доступа к ресурсу задача должна сначала 'взять' токен (стать держателем токена). Когда задача - держатель токена завершила работу с ресурсом, она должна 'отдать' токен обратно. Только когда токен свободен, другая задача может взять токен и тогда получить доступ к общему ресурсу. Задаче не разрешено обращаться к общему ресурсу, за исключением того случая, когда она держит токен. Этот механизм показан на рисунке 36.

Несмотря на то, что мьютексы и семафоры имеют много общих характеристик, сценарий на рисунке 36 (где мьютексы используется для взаимного исключения) полностью отличается от сценария рисунка 30 (где двоичные семафоры используются для синхронизации). Главное отличие - в том, что происходит с семафором после того, как он был получен:

● Семафор, который используется для взаимного исключения, должен быть всегда возвращен.

● Семафор, который используется для синхронизации нормально отбрасывается и не возвращается.

            

![[Pasted image 20220125215119.png]]

Рис. 36. Взаимное исключение, реализованное с использованием мьютекса

Механизм работает только по инициативе разработчика приложения. Нет никаких причин, почему бы задаче не получить доступ к ресурсу в любой момент, однако каждая задача "подчиняется" правилу доступа, что она обязательно должна сначала стать держателем мьютекса.

Мьютекс является типом семафора. Хендлы к различным типам семафоров FreeRTOS сохраняются в переменной типа xSemaphoreHandle.

Перед тем, как мьютекс может быть реально использован, он сначала должен быть создан. Для создания семафора типа мьютекс используется API функция xSemaphoreCreateMutex().

xSemaphoreHandle xSemaphoreCreateMutex( void );

которая возвращает созданный мьютекс, или NULL, если недостаточно памяти.

Следующий код показывает механизм работы с мьютексом:

if( xSemaphoreTake( xMutex, portMAX_DELAY ) == pdTRUE )

{

 _// Здесь происходит защищенный доступ к ресурсу._ 

 _// Отдаем "токен"._

 xSemaphoreGive( xMutex );

}

**Возвращаемое значение**

**Описание**

Возвращаемое значение

Если возвращен NULL, то мьютекс не может быть создан из-за недостатка памяти в куче (heap), так как FreeRTOS должна взять оттуда память для структур данных мьютекса..

Ненулевое возвращенное значение показывает, что мьютекс был успешно создан. Возвращенное значение должно быть сохранено как хендл к созданному мьютексу (для последующего использования в вызовах API функций).


# 66.Мьютексы как примитивы синхронизации 
          

Мью́текс — примитив синхронизации, обеспечивающий взаимное исключение исполнения критических участков кода.

### Событие (event)

Пожалуй, самый простой и фундаментальный синхронизирующий объект. Это всего лишь флаг, которому функциями SetEvent/ResetEvent можно задать состояние: сигнализирующее или нейтральное. Событие – это самый удобный способ передать сигнал ожидающему потоку, что некое событие свершилось (потому оно так и называется), и можно продолжать работу. С помощью события мы легко решим проблему синхронизации при инициализации рабочего потока:

// Пусть для простоты хэндл события будет храниться в глобальной переменной:

HANDLE g_hEventInitComplete = NULL; // никогда не оставляем переменную неинициализированной!

{ // код в главном потоке

// создаем событие

g_hEventInitComplete = ::CreateEvent( NULL,

FALSE, // об этом параметре мы еще поговорим

FALSE, // начальное состояние - нейтральное

NULL );

if( !g_hEventInitComplete ) { /* не забываем про обработку ошибок */ }

// создаем рабочий поток

DWORD idWorkerThread = 0;

HANDLE hWorkerThread = ::CreateThread( NULL, 0, &WorkerThreadProc, NULL, 0, &idWorkerThread );

if( !hWorkerThread ) { /* обработка ошибки */ }

...

...

// ждем сигнала от рабочего потока

DWORD dwWaitResult = ::WaitForSingleObject( g_hEventInitComplete, INFINITE );

if( dwWaitResult != WAIT_OBJECT_0 ) { /* ошибка */ }

// вот теперь можно быть уверенным, что рабочий поток завершил инициализацию.

...

VERIFY( ::CloseHandle( g_hEventInitComplete ) ); // не забываем закрывать ненужные объекты

g_hEventInitComplete = NULL;

}

// функция рабочего потока

DWORD WINAPI WorkerThreadProc( LPVOID _parameter )

{

InitializeWorker(); // инициализация

// сигнализируем, что инициализация завершена

BOOL isOk = ::SetEvent( g_hEventInitComplete );

if( !isOk ) { /* ошибка */ }

...

}

Надо заметить, что существуют две заметно отличающиеся разновидности событий. Мы можем выбрать одну из них с помощью второго параметра функции CreateEvent. Если он TRUE, создается событие, состояние которого управляется только вручную, то есть функциями SetEvent/ResetEvent. Если же он FALSE, будет создано событие с автосбросом. Это означает, что как только некий поток, ожидающий данного события, будет освобожден сигналом от этого события, оно автоматически будет сброшено обратно в нейтральное состояние. Наиболее ярко их отличие проявляется в ситуации, когда одного события ожидают сразу несколько потоков. Событие с ручным управлением подобно стартовому пистолету. Как только оно будет установлено в сигнализирующее состояние, будут освобождены сразу все потоки. Событие же с автосбросом похоже на турникет в метро: оно отпустит лишь один поток и вернется в нейтральное состояние.

### Мьютекс (mutex )

По сравнению с событием это более специализированный объект. Обычно он используется для решения такой распространенной задачи синхронизации, как доступ к общему для нескольких потоков ресурсу. Во многом он похож на событие с автосбросом. Основное отличие состоит в том, что он имеет специальную привязку к конкретному потоку. Если мьютекс находится в сигнальном состоянии – это означает, что он свободен и не принадлежит ни одному потоку. Как только некий поток дождался этого мьютекса, последний сбрасывается в нейтральное состояние (здесь он как раз похож на событие с автосбросом), а поток становится его хозяином до тех пор, пока явно не освободит мьютекс функцией ReleaseMutex, или же не завершится. Таким образом, чтобы быть уверенным, что с разделяемыми данными одновременно работает только один поток, следует все места, где происходит такая работа, окружить парой: WaitFor - ReleaseMutex:

HANDLE g_hMutex;

// Пусть хэндл мьютекса хранится в глобальной переменной. Его конечно надо создать заранее, до запуска рабочих потоков. Будем считать, что это уже было сделано.

{

...

int iWait = ::WaitForSingleObject( g_hMutex, INFINITE );

switch( iWait ) {

case WAIT_OBJECT_0: // Все нормально

break;

case WAIT_ABANDONED: /* Какой-то поток завершился, забыв вызвать ReleaseMutex. Скорее всего, это означает ошибку в вашей программе! Поэтому на всякий случай вставим здесь ASSERT, но в окончательно версии (release) будем считать этот код успешным. */

ASSERT( false );

break;

default:

// Здесь должна быть обработка ошибки.

}

// Защищенный мьютексом участок кода.

ProcessCommonData();

VERIFY( ::ReleaseMutex( g_hMutex ) );

...

}

Чем же мьютекс лучше события с автосбросом? В приведенном примере его также можно было бы использовать, только ReleaseMutex надо было бы заменить на SetEvent. Однако может возникнуть следующая сложность. Чаще всего работать с общими данными приходится в нескольких местах. Что будет, если ProcessCommonData в нашем примере вызовет функцию, которая работает с этими же данными и в которой уже есть своя пара WaitFor - ReleaseMutex (на практике это встречается весьма часто)? Если бы мы использовали событие, программа, очевидно, зависла бы, поскольку внутри защищенного блока событие находится в нейтральном состоянии. Мьютекс же устроен более хитро. Для потока-хозяина он всегда остается в сигнализирующем состоянии, несмотря на то, что для всех остальных потоков он при этом находится в нейтральном. Поэтому если поток захватил мьютекс, повторный вызов WaitFor функции не приведет к блокировке. Более того, в мьютекс встроен еще и счетчик, так что ReleaseMutex должна быть вызвана столько же раз, сколько было вызовов WaitFor. Таким образом, мы можем смело защищать каждый участок кода, работающий с общими данными, парой WaitFor - ReleaseMutex, не волнуясь о том, что этот код может быть вызван рекурсивно. Это делает мьютекс очень простым в использовании инструментом.


# 67.Критическая секция, понятие, пример использования 
Во избежание повреждений данных каждая задача получает исключительный доступ к ресурсам. Для реализации взаимного исключения используются критические секции.

Критическая секция – это участок кода, который обладает следующим свойством: если процесс вошел в критическую секцию, то его прервать нельзя. То есть во время выполнения критической секции, когда прерывания отключаются.

Когда необходимо, то выбирается контекст соответствующей задачи (из памяти – области сохранения процесса) и загружается в регистры ЦП. Контекст процесса содержит сведения о том, как процесс должен реагировать на какой-либо сигнал, сколько времени ЦП процесс недавно использовал, и другие важные сведения. 

# 68.Критическая секция кода и ее использование в СРВ 

![[Pasted image 20220125215208.png]]

# 69.Реентерабельность кода, понятие и назначение в СРВ 
![[Pasted image 20220125215214.png]]

# 70.Понятие и использование Взаимного исключения в СРВ 
            

**11.** Взаимные исключения – это способ синхронизировать параллельную работу трех процессов, которые используют разделяемые критические ресурсы ![](file:///C:/Users/Admin/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif) 

![](file:///C:/Users/Admin/AppData/Local/Temp/msohtmlclip1/01/clip_image004.gif)

(лекция №8)

# 71.Семафоры. Понятие, виды и их использование в СРВ 

![](file:///C:/Users/Admin/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif)

![](file:///C:/Users/Admin/AppData/Local/Temp/msohtmlclip1/01/clip_image004.gif)


# 72.Сигналы. Виды и использование в СРВ

Сигналы расширения POSIX 1003.1b играют очень важную роль в приложениях реального времени. Они используются для уведомления процессов о возникновении асинхронных событий, таких как завершение работы таймера высокого разрешения, завершение асинхронного ввода/вывода, приём сообщения в пустой очереди сообщений POSIX, и так далее. Некоторые преимущества, которыми обладают сигналы реального времени по отношению к нативным сигналам, перечислены в Таблице

![[Pasted image 20220125215300.png]]